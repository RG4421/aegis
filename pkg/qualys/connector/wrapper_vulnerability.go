package connector

import (
	"context"
	"fmt"
	"github.com/nortonlifelock/aegis/pkg/domain"
	"github.com/nortonlifelock/aegis/pkg/qualys"
	"strconv"
	"strings"
	"sync"
	"time"
)

// the only field that needs to be provided on creation is the QVulnerability
// the rest are set automatically VIA lazy loading
type vulnerabilityInfo struct {
	v *qualys.QVulnerability

	lazyLoadLock   sync.Mutex
	loadedCVSS     bool
	loadedSoftware bool

	cvss2Base   float32
	cvss3Base   *float32
	cvss2Vector string
	cvss3Vector string

	cves       []string
	vendorRefs []string
	software   string
}

func (vi *vulnerabilityInfo) ID() string {
	return ""
}

func (vi *vulnerabilityInfo) SourceID() string {
	return strconv.Itoa(vi.v.QualysID)
}

func (vi *vulnerabilityInfo) Name() string {
	return vi.v.Title
}

func (vi *vulnerabilityInfo) CVSS2() float32 {
	vi.lazyLoadLock.Lock()
	defer vi.lazyLoadLock.Unlock()
	if !vi.loadedCVSS {
		vi.cvss2Base, vi.cvss3Base, vi.cvss2Vector, vi.cvss3Vector = vi.extractCVSSInformation()
		vi.loadedCVSS = true
	}

	return vi.cvss2Base
}

func (vi *vulnerabilityInfo) CVSS3() *float32 {
	vi.lazyLoadLock.Lock()
	defer vi.lazyLoadLock.Unlock()
	if !vi.loadedCVSS {
		vi.cvss2Base, vi.cvss3Base, vi.cvss2Vector, vi.cvss3Vector = vi.extractCVSSInformation()
		vi.loadedCVSS = true
	}

	return vi.cvss3Base
}

func (vi *vulnerabilityInfo) Description() string {
	return vi.v.Consequence
}

func (vi *vulnerabilityInfo) Threat() *string {
	return &vi.v.Diagnosis
}

func (vi *vulnerabilityInfo) Solutions(ctx context.Context) (<-chan domain.Solution, error) {
	var out = make(chan domain.Solution)
	go func() {
		defer close(out)
		out <- &solution{vi.v.Solution}
	}()

	return out, nil
}

func (vi *vulnerabilityInfo) Severity() int {
	return vi.v.Severity
}

func (vi *vulnerabilityInfo) Patchable() *string {
	var val = "No"
	if vi.v.Patchable {
		val = "Yes"
	}
	return &val
}

// CVSS2Vector do we really need these two fields stored in the DB?
func (vi *vulnerabilityInfo) CVSS2Vector() string {
	vi.lazyLoadLock.Lock()
	defer vi.lazyLoadLock.Unlock()
	if !vi.loadedCVSS {
		vi.cvss2Base, vi.cvss3Base, vi.cvss2Vector, vi.cvss3Vector = vi.extractCVSSInformation()
		vi.loadedCVSS = true
	}

	return vi.cvss2Vector
}

func (vi *vulnerabilityInfo) CVSS3Vector() string {
	vi.lazyLoadLock.Lock()
	defer vi.lazyLoadLock.Unlock()
	if !vi.loadedCVSS {
		vi.cvss2Base, vi.cvss3Base, vi.cvss2Vector, vi.cvss3Vector = vi.extractCVSSInformation()
		vi.loadedCVSS = true
	}

	return vi.cvss3Vector
}

// Software returns a CSV detailing all the software a vulnerability applies to
func (vi *vulnerabilityInfo) Software() string {
	vi.lazyLoadLock.Lock()
	defer vi.lazyLoadLock.Unlock()
	if !vi.loadedSoftware {
		for i := 0; i < len(vi.v.Software); i++ {
			vi.software += vi.v.Software[i].Product
			if i < len(vi.v.Software)-1 {
				vi.software += ","
			}
		}
		vi.loadedSoftware = true
	}

	return vi.software
}

// DetectionInformation returns //TODO
func (vi *vulnerabilityInfo) DetectionInformation() string {
	return vi.v.DetectionInformation
}

func (vi *vulnerabilityInfo) Category() *string {
	return &vi.v.Category
}

// References returns vulnerability references that apply to the vulnerability
func (vi *vulnerabilityInfo) References(ctx context.Context) (<-chan domain.VulnerabilityReference, error) {
	var out = make(chan domain.VulnerabilityReference)

	go func(out chan<- domain.VulnerabilityReference) {
		defer close(out)

		cves, vendors := vi.extractCVEs(), vi.extractVendors()

		for _, cve := range cves {
			select {
			case <-ctx.Done():
				return
			case out <- &vendorReference{source: domain.CVE, name: cve}:
			}
		}

		for _, vendor := range vendors {
			select {
			case <-ctx.Done():
				return
			case out <- &vendorReference{source: domain.Vendor, name: vendor}:
			}
		}
	}(out)

	return out, nil
}

func (vi *vulnerabilityInfo) extractVendors() []string {
	vi.lazyLoadLock.Lock()
	defer vi.lazyLoadLock.Unlock()
	if vi.vendorRefs == nil {
		vi.vendorRefs = make([]string, len(vi.v.VendorReferences))
		for i := range vi.v.VendorReferences {
			vi.vendorRefs[i] = vi.v.VendorReferences[i].ID
		}
	}

	return vi.vendorRefs
}

func (vi *vulnerabilityInfo) extractCVEs() []string {
	vi.lazyLoadLock.Lock()
	defer vi.lazyLoadLock.Unlock()
	if vi.cves == nil {
		vi.cves = make([]string, len(vi.v.CVEs))
		for i := range vi.v.CVEs {
			vi.cves[i] = vi.v.CVEs[i].ID
		}
	}

	return vi.cves
}

func (vi *vulnerabilityInfo) Updated() time.Time {
	return vi.v.LastServiceModification
}

// extractCVSSInformation extract the CVSS2 and CVSS3 vectors and base scores from the Qualys vulnerability object
// from what I've seen, a CVSS2 score is always present, but a CVSS3 is not
// therefore, a pointer to the CVSS3 score is passed returned. If a nil value was returned, a CVSS score was not provided
func (vi *vulnerabilityInfo) extractCVSSInformation() (float32, *float32, string, string) {
	var cvssAttributes = make([]string, 0)
	var cvss3Attributes = make([]string, 0)
	var cvssBase = float32(0.0)
	var cvss3Base *float32
	// The CVSS/CVSS3 is stored as json, so we store individual fields where they're found and build the json later
	if vi.v.CVSS != nil {
		cvssBase = vi.v.CVSS.Base

		if vi.v.CVSS.Impact != nil {
			cvssAttributes = append(cvssAttributes,
				fmt.Sprintf("\"IC\":%d", vi.v.CVSS.Impact.Confidentiality),
				fmt.Sprintf("\"IA\":%d", vi.v.CVSS.Impact.Availability),
				fmt.Sprintf("\"II\":%d", vi.v.CVSS.Impact.Integrity))
		}
		if vi.v.CVSS.Access != nil {
			cvssAttributes = append(cvssAttributes,
				fmt.Sprintf("\"AC\":%d", vi.v.CVSS.Access.Complexity),
				fmt.Sprintf("\"AV\":%d", vi.v.CVSS.Access.Vector))
		}

		cvssAttributes = append(cvssAttributes,
			fmt.Sprintf("\"RC\":%d", vi.v.CVSS.ReportConfidence),
			fmt.Sprintf("\"RL\":%d", vi.v.CVSS.RemediationLevel),
			fmt.Sprintf("\"Exploitability\":%d", vi.v.CVSS.Exploitability),
			fmt.Sprintf("\"Auth\":%d", vi.v.CVSS.Authentication),
			fmt.Sprintf("\"Base\":%.1f", vi.v.CVSS.Base),
			fmt.Sprintf("\"Temporal\":%.1f", vi.v.CVSS.Temporal))
	}
	if vi.v.CVSS3 != nil {
		cvss3Base = &vi.v.CVSS3.Base

		if vi.v.CVSS3.Impact != nil {
			cvss3Attributes = append(cvss3Attributes,
				fmt.Sprintf("\"IC\":%d", vi.v.CVSS3.Impact.Confidentiality),
				fmt.Sprintf("\"IA\":%d", vi.v.CVSS3.Impact.Availability),
				fmt.Sprintf("\"II\":%d", vi.v.CVSS3.Impact.Integrity))
		}
		if vi.v.CVSS3.Access != nil {
			cvss3Attributes = append(cvss3Attributes,
				fmt.Sprintf("\"AC\":%d", vi.v.CVSS3.Access.Complexity),
				fmt.Sprintf("\"AV\":%d", vi.v.CVSS3.Access.Vector))
		}

		cvss3Attributes = append(cvss3Attributes,
			fmt.Sprintf("\"RC\":%d", vi.v.CVSS3.ReportConfidence),
			fmt.Sprintf("\"RL\":%d", vi.v.CVSS3.RemediationLevel),
			fmt.Sprintf("\"Exploitability\":%d", vi.v.CVSS3.Exploitability),
			fmt.Sprintf("\"Auth\":%d", vi.v.CVSS3.Authentication),
			fmt.Sprintf("\"Base\":%.1f", vi.v.CVSS3.Base),
			fmt.Sprintf("\"Temporal\":%.1f", vi.v.CVSS3.Temporal))
	}
	// Buld the json strings
	var cvssString = "{" + strings.Join(cvssAttributes, ",") + "}"
	var cvss3String = "{" + strings.Join(cvss3Attributes, ",") + "}"

	return cvssBase, cvss3Base, cvssString, cvss3String
}
