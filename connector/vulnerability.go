package connector

import (
	"context"
	"github.com/benjivesterby/validator"
	"github.com/nortonlifelock/domain"
	"github.com/nortonlifelock/log"
	"github.com/nortonlifelock/nexpose"
	"github.com/pkg/errors"
	"sync"
	"time"
)

type vulnerability struct {
	vuln   *nexpose.Vulnerability
	api    *nexpose.Session
	logger log.Logger

	solutionMut sync.Mutex
	solutions   []domain.Solution

	referenceMut sync.Mutex
	references   []domain.VulnerabilityReference
}

func (v *vulnerability) ID() string {
	return ""
}

func (v *vulnerability) SourceID() string {
	return v.vuln.ID
}

func (v *vulnerability) Name() string {
	return v.vuln.Title
}

func (v *vulnerability) Description() string {
	var desc string
	if v.vuln.Description != nil {
		desc = v.vuln.Description.Text
	}

	return desc
}

func (v *vulnerability) CVSS2() float32 {

	var cvss float32
	if validator.IsValid(v) &&
		v.vuln.Cvss != nil &&
		v.vuln.Cvss.V2 != nil {

		cvss = v.vuln.Cvss.V2.Score
	}

	return cvss
}

func (v *vulnerability) Threat() *string {
	return nil
}

func (v *vulnerability) Category() *string {
	return nil
}

func (v *vulnerability) CVSS3() *float32 {

	var cvss *float32
	if validator.IsValid(v) &&
		v.vuln.Cvss != nil &&
		v.vuln.Cvss.V3 != nil {

		cvss = &v.vuln.Cvss.V3.Score
	}

	return cvss
}

func (v *vulnerability) Solutions(ctx context.Context) (<-chan domain.Solution, error) {

	var solutions = make(chan domain.Solution)
	var err error

	if validator.IsValid(v) {

		go func(solutions chan<- domain.Solution) {
			defer handleRoutinePanic(v.logger)
			defer close(solutions)

			v.solutionMut.Lock()
			defer v.solutionMut.Unlock()

			if v.solutions != nil {

				// Push the cached solutions onto the channel
				for _, solution := range v.solutions {
					solutions <- solution
				}

			} else {
				var sols <-chan *nexpose.Solution
				if sols, err = v.api.GetVulnerabilitySolutions(ctx, v.vuln.ID); err == nil {

					for {
						select {
						case <-ctx.Done():
							return
						case solution, ok := <-sols:
							if ok && solution != nil {

								// Append the solution to the internal cache
								v.solutions = append(v.solutions, solution)

								// Return the solution to the requesting code
								solutions <- solution
							} else {
								return
							}
						}
					}

				} else {
					v.logger.Send(log.Errorf(err, "error loading solutions for vulnerability [%s]", v.vuln.ID))
				}
			}

		}(solutions)
	} else {
		err = errors.New("invalid vulnerability object from nexpose")
	}

	return solutions, err
}

// Unaware of any field that tells if a vulnerability is patchable
// if you find one, please reference it in this method
func (v *vulnerability) Patchable() *string {
	return nil
}

func (v *vulnerability) References(ctx context.Context) (<-chan domain.VulnerabilityReference, error) {
	var references = make(chan domain.VulnerabilityReference)
	var err error

	if validator.IsValid(v) {

		go func(references chan<- domain.VulnerabilityReference) {
			defer handleRoutinePanic(v.logger)
			defer close(references)

			v.referenceMut.Lock()
			defer v.referenceMut.Unlock()

			if v.references != nil {

				// Push the cached solutions onto the channel
				for _, ref := range v.references {
					references <- ref
				}

			} else {
				var refs <-chan *nexpose.VulnerabilityReference
				if refs, err = v.api.GetVulnerabilityReferences(ctx, v.vuln.ID, ""); err == nil {

					for {
						select {
						case <-ctx.Done():
							return
						case reference, ok := <-refs:
							if ok && reference != nil {
								// Append the reference to the internal cache
								v.references = append(v.references, reference)

								// push the reference to the requesting code
								references <- reference
							} else {
								return
							}
						}
					}

				} else {
					v.logger.Send(log.Errorf(err, "error loading references for vulnerability [%s]", v.vuln.ID))
				}
			}
		}(references)
	} else {
		err = errors.New("invalid vulnerability object from nexpose")
	}

	return references, err
}

func (v *vulnerability) Software() string {
	return ""
}

func (v *vulnerability) DetectionInformation() string {
	return ""
}

func (v *vulnerability) Updated() time.Time {
	var modified time.Time
	var err error
	if modified, err = time.Parse("2006-01-02", v.vuln.Modified); err != nil {
		v.logger.Send(log.Errorf(err, "error while parsing time modified for vulnerability"))
	}
	return modified
}

func (v *vulnerability) Validate() (valid bool) {
	if v.vuln != nil {
		if v.api != nil {
			valid = true
		}
	}

	return valid
}
